
【翻译中 by arthurlee】

# [注释你的代码](https://npf.io/2017/11/comments/)
2017年11月17日 作者：[Nate Finch](https://npf.io)

每隔一段时间，网上总会突然出现一些令人讨厌的帖子，说写注释是不好的，它存在的唯一原因是因为代码写得不够好。对于这些，我完全不能认同。

## 烂代码
他们这样说也不完全是错的，你的代码不够好。我的和其他人的也都是。代码慢慢变烂。你知道什么时候代码最烂吗？当你六个月没有碰代码的时候。当回过头再看的时候，你会好奇：“这个作者到底是在想什么？”（于是，使用 git blame 来查看历史记录，没想到代码竟然是自己写的。因为这是你的代码。）

反对注释者的论点是需要注释的唯一原因是你的代码不够“清晰”。如果代码重构、命名和组织的更好好，那么就不需要注释了。

今天，当整个项目和问题空间都在你的脑袋里的时候，你自然会觉得代码是干净、清晰和优雅的。但是，当六个月后，这些代码可能对你已经有些模糊；又或是，CTO 刚好在生产系统上突然发现一个关键性的 bug，在主管紧盯的情况下，一些可怜的家伙不得不去调试你的代码的时候。

你了解的一段代码，去想象其他人为什么不能理解的原因，是非常难以掌握的技能。不过，这个具有无可估量的价值，几乎和第一次就能写出好的代码的能力一样重要。在软件行业中，几乎没有人是独行侠。即使真的一个人写代码，你也会忘记为什么写出这样的代码或者昨天深夜“工程代码”核心部分的确切目的。一旦你离职，接替你的人不得不去理解每一个仅在你的脑袋里的小偏好和诀窍。

所以，写一个即使在现在看来过于浅显的注释不是一个坏事情。有时候，甚至会带来巨大的帮助。

## 不写注释经常导致代码更难以理解
一些人声称如果移除注释，将会使代码更好，因为你会用更清晰的代码来补偿。我对此亦不以为然，因为我不认为有人会实际写上一些次佳的代码，并且放注释来解释（除了 `// TODO: 这是一个临时的解决方法，我会稍后修正` 之外）。我们都会写出在各种外部条件下（通常是时间）认为最好的代码。

为去除注释而重构代码的问题在于，这个经常会导致更坏的代码，而不是更好的代码。权威的例子是重构一行复杂的代码，将之提取到一个名字望文生义的函数中。这个听起来不错，除了现在你为正在阅读代码的人引入了一个上下文切换。替代真实代码的是一个函数调用，他们不得不滚动到函数定义的地方，记住和对照函数声明和调用的参数，并且将函数返回代入到调用的地方。

另外，清晰的函数名仅仅适合非常短小的注释。任何超过一小段短语的注释不能（或者不应该）形成一个函数名。因此，你最终会得到一个头上有注释的函数。

的确，一个非常短小的函数就可能导致困惑和更复杂的代码。如果看到这样的函数，我就会去搜索这个函数被调用的所有地方。如果只有只有一个地方使用，我就会去考虑这是否确实是一个封装了全局逻辑的通用代码块（譬如 `NameToUserID`），或者这个函数是严重依赖调用端的特定状态和实现的定制代码，并且不能在其他地方正确工作。随着把这些放到一个函数里面，你本质上在其余的代码中暴露了实现细节，不应该这么草率的做出这样的决定。即使你知道这不是一个其他人应该调用的函数，当即便这样做不合适，其他人还会在某个时刻调用之。

小函数的问题在 Cindy Sridharan [medium 网站上的帖子](https://medium.com/@copyconstruct/small-functions-considered-harmful-91035d316c29)中有更加详细的阐述。

我们甚至可以深入到厂变量名和短的的比较，但是就此打住吧，一般你不可能接受更长的变量名了。除非你的变量名就是你想写的完整的注释，否则你还是会丢失信息而不得不添加到注释中。我认为我们可以达成一致，`usernameStrippedOfSpacesWithDotCSVExtension` 是一个可怕的变量名称。

我不是说我们不应该尽量去让我们的代码清晰和优雅，当然需要，这是一个出色的开发人员的特点。但是，代码清晰性和有注释是正交的，好的注释也是出色的开发人员的特点。

## 没有不良的注释
在这些讨论中给出的不良注释的例子都是些小的错误，除了那些刚起步的编程课程外，在现实中几乎不会碰到。

```javascript
// 实例化一个错误对象
var err error
```

不错，这很清楚不是有个有用的注释。但同时，这实际上也没有什么坏处。在浏览代码时，虽然有些不待见，但也很容易被忽略。如果开发者能够留下一个节省我数个小时工作的有用注释的话，我愿意看成百这样简单的注释。

我非常确信不会读到任何代码说“伙计，这段代码非常容易理解，所以不会写任何注释。” 实际情况恰恰完全相反。

实际上，我找出了一些我认为在缺失注释方面非常严重的代码 - Go 标准库。这些代码非常正确和精良，但在很多情况下，如果在看代码前对其功能没有深刻的理解，理解这些代码为什么这么设计将是个挑战。少量关于设计的逻辑和原因将使 Go 标准库更加容易阅读。基于此，我特别关注在实现代码里面的注释，而不是通常的公开函数的文档注释（这些当然也非常棒）。

## 任何注释胜过无注释
另外一个例子反注释者喜欢拿出来的是用下面的简洁有力的图片来展示智慧:
![pithy image](https://npf.io/comments.jpg)

哈，极其滑稽的，有人更换了内容但是没有更新注释。

但是，这是个20年前的问题了，但是普遍不进行代码审查。不过，现在（代码审查）已经普遍了。如果检查注释和实现是否匹配不是你们代码审核流程的一部分，那么你最好检查一下你们的代码审核流程。

这不是说不会犯错误，实际上我昨天刚提交了一个“注释和实现不一致”的 bug。类似“无注释比错误注释好”的言论初听起来是正确的，除了你认识到如果没有注释，开发人员会猜测代码的用途，并且很可能猜错，这个比错误注释的概率更好。

即使这种情况发生了，代码被修改了，你依然可以获取代码以前用途的有价值的信息。修改仅仅和原先有些许不同罢了，代码依旧做着基本相同的事情。为了控制版本和向后兼容，同一个函数在不改变名字和签名的情况下，在功能上发生剧烈变化的频率有多少？基本上很少吧。

就拿我昨天发现的 bug 来说，我们调用 `client.SetKeepAlive(60)`。而SetKeepAlive 函数的注释是“SetKeepAlive 在发送 PING 请求之前，客户端需要等待指定数量的时间（以秒为单位）”。看上去很棒，不是吗？知道我注意到 SetKeepAlive 的参数是 time.Duration。60这个值，如果没有其他指定的单位，那么将使用 Go 的 duration 缺省单位纳秒。哎呦，某人更新了该函数，使用 Duration 类型来替换 Int。有趣的是，它仍然向下取整到了最接近的秒数，所以注释不是不正确，只是有些误导罢了。

## 为什么？
最重要的注释是为什么要注释。为什么代码是按照设计来执行的？为什么这个 ID 需要少于24个字符？为什么要在 Linux 下面隐藏这个选项？诸如此类。这些问题为什么重要的原因是你无法从代码中提炼出来。他们组织开发人员学习的培训课程，商业和其他系统的外部约束，等等。这些注释是价值无量的，并且几乎无法其他途径获得（例如，函数取名应该反映函数做什么而不是为什么）。

注释代码的用途不是比较有用，因为有足够的时间和努力，你总能够找出代码的功能。通过定义，代码告诉你它的功能。这不意味着你不应该写任何注释。确实应该力争写出最清晰简洁的代码，但是注释是只有的，如果你觉得有人会错误理解一些代码或者理解有困难，应该写上一些注释。至少，这个会节省他们半个小时来理解你的代码，这个会以最有帮助的方式避免他们错误的方式来修改或者使用他们，从而导致 bug。

## 测试
一些人认为函数的功能测试就相当于文档。某种程度上说，确实是这样的。但是，在我对于有效文档的列表中，它的排名一般非常低。为什么？因为它们机器精确而且琐碎，仅仅覆盖了功能的很窄的一部分。每一个测试仅确切地测试一个特定的输入和一个特定的输出。任何超过一个简单函数的情况，你很可能需要一大串代码来构建输入和输出。

对于大多数编程而言，主要描述一个番薯的行为比写代码去完整测试要容易。很多时候我的测试代码行数倍于函数实现本身，然而文档注释仅仅需要寥寥几行而已。

此外，测试仅仅解释了函数的功能。函数的功能期望是什么？它们不能解释为什么，但是就像前面提到的，缘由总是更重要的。

你确实应该要测试你的代码，通过一些边界测试案例，测试对于判定代码具有希望的行为非常有作用。但是一般而言，如果我必须通用阅读测试来理解代码，那么这就是一个需要写更多更好注释的告警了。

## 结论
我感到有用和无用注释的边界是非常困难去发现的（除了一些非常简单的例子以外），所有我宁愿人们站在多写注释的这边。你不会知道下一个可能阅读你带的人是谁，所以能帮助他们的是尽你所能写一大串的注释。尽量写到你认为太多了，然后再写多一些，这估计是个合适的数量。

----------------

via: https://npf.io/2017/11/comments/

作者：[Nate Finch](https://npf.io/about/)
译者：[arthurlee](https://github.com/arthurlee)
校对：[校对者ID](https://github.com/校对者ID)

本文由 [GCTT](https://github.com/studygolang/GCTT) 原创编译，[Go中文网](https://studygolang.com/) 荣誉推出。

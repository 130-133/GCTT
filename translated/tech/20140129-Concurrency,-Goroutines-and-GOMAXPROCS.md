
https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html

# 并发，协程和最大CPU核数（Concurrency, Goroutines and GOMAXPROCS）

William Kennedy 2014年1月29日

## 介绍

刚刚加入[GO-Minami](http://www.meetup.com/Go-Miami/) 组织的新人经常会说想学习更多有关 go 并发的知识。并发好像在每个语言中都是热门话题，当然我第一次听说 go 语言时也是因为这个点。而 Rob Pike 的一段 [GO Concurrency Patterns](http://www.youtube.com/watch?v=f6kdp27TYZs) 视频才让我真真意识到我需要学习这门语言。

为了了解为什么 go 语言写并发代码更容易更健壮，我们首先需要理解并发程序是什么，和并发程序会导致什么样的结果。在文章中我不就不讨论 CSP (
通信顺序过程)了，这个是 go 语言 channel 实现的基础。这篇文章将关注点放在什么是并发编程，goroutines 在其中扮演什么角色、GOMAXPROCS 环境变量和 runtime 函数如何影响文章中写的 go 程序。

## 进程和线程

当我们打开一个应用时，比如现在打开的用于写文章的浏览器，操作系统就会为这个应用创建一个进程。这个进程扮演的角色是作为这个应用的一个容器，这个容器可以包含应用运行所需要的资源。这些资源包括内存地址空间，文件引用，设备和线程。

线程相对于进程而言，线程是由操作系统调度的一个执行过程的路线，而这个执行过程就是我们对我们方法中代码的执行过程。一个进程开始于一个线程，这个线程是主线程，并且当主线程结束时这个进程也就结束了。那是因为这个主线程是应用的启动的源点。另一分方面，主线程可以启动更多线程，这些被主线程启动的线程又可以启动更多的线程。

操作系统调度器去决定哪个个可用进程中的线程去执行，而不管这个线程到底属于哪个进程。每个操作系统都有它们自己的算法来决定如何选择执行线程。所以对于我们写并发程序而言，最好不要针对某一个算法而个性化开发。除此之外，每个操作系统升级新版本时他们的算法就会相应地发生变化，所以写并发编程就像是玩一个危险的游戏。

## 协程和并行

在 go 中任何方法或则函数都可以作为一个协程来调用,我们可以认为主函数就是一个通过协程运行的，然而 Go 运行时并没有启动其他协程。协程可以被认为是轻量级的，因为它使用很少的内存和资源，除此之外 , 协程初始化时需要的栈空间是很小的。在 go1.2 版本前初始栈空间需要4K，现在从 1.4 版本后是8K。栈空间的大小会根据协程的需要自动进行扩大。

操作系统是根据当前机器的可用处理器个数来调度线程，Go 运行时是以一个操作系统级别的线程组成的逻辑处理器来执行协程调度的。默认情况下，Go 运行时会分配一个单核的逻辑处理器去处理所有在程序中创建的协程。即使是一个单核的逻辑处理器和操作系统线程，也可以以惊人的效率和性能来调度成千上万个协程并发运行。我是不建议添加逻辑处理器的，但是如果你想并行运行协程，你可以通过设置 GOMAXPROCS 环境变量或者 runtime 方法来完成。

并发不是平行。并行是指当两个或两个以上的线程在不同的处理器同时执行的现象。如果你通过定义 runtime 去使用1个以上的逻辑处理器，调度器将会分配这些协程在不同的逻辑处理器上，这就会导致协程运行在不同的操作系统级别的线程上。然而，为了并行运行程序你需要一个多核处理器的机器。如果不是这样，即使你的 runtime 设置的是多核逻辑处理器，程序还是运行在一个单核的处理器上。 

## 并发的例子

让我们来创建一个小的程序来展示 Go 运行协程时的并发性。在这个例子中我们是在一个逻辑处理器上运行的：

```package main

import (
    "fmt"
    "runtime"
    "sync"
)

func main() {
    runtime.GOMAXPROCS(1)

    var wg sync.WaitGroup
    wg.Add(2)

    fmt.Println("Starting Go Routines")
    go func() {
        defer wg.Done()

        for char := ‘a’; char < ‘a’+26; char++ {
            fmt.Printf("%c ", char)
        }
    }()

    go func() {
        defer wg.Done()

        for number := 1; number < 27; number++ {
            fmt.Printf("%d ", number)
        }
    }()

    fmt.Println("Waiting To Finish")
    wg.Wait()

    fmt.Println("\nTerminating Program")
}
```

